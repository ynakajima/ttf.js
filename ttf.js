/**
 * ttf.js - JavaScript TrueType Font library.
 * Copyright (c) 2013 ynakajima (http://github.com/ynakajima)
 *
 * Released under the MIT license.
 *
 * TTFDataView.getLongDateTime() method is:
 *   copyright (C) 2000,2001,2002,2003,2004,2005,2006,2007,2008
 *   George Williams. Released under BSD license.
 *
 */        
// Generated by CoffeeScript 1.4.0
(function() {
  var CompositeGlyphData, GlyfTable, Glyph, HeadTable, HheaTable, HmtxTable, LocaTable, MaxpTable, OS_2Table, SimpleGlyphData, TTFDataView, TrueType, jDataView, ttfjs;

  CompositeGlyphData = (function() {

    function CompositeGlyphData(GID, glyfTable) {
      if (GID == null) {
        GID = null;
      }
      if (glyfTable == null) {
        glyfTable = null;
      }
      this.GID = GID;
      this.type = 'composite';
      this.numberOfContours = 0;
      this.xMin = 0;
      this.yMin = 0;
      this.xMax = 0;
      this.yMax = 0;
      this.glyfTable = glyfTable;
      this.components = [];
    }

    CompositeGlyphData.prototype.toSVGPathString = function(options) {
      var component, glyph, m, matrix, newMatrix, pathString, relative, t, _m, _matrix, _ref, _ref1;
      matrix = (_ref = options != null ? options.matrix : void 0) != null ? _ref : void 0;
      relative = (_ref1 = options != null ? options.relative : void 0) != null ? _ref1 : false;
      pathString = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.components;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          component = _ref2[_i];
          t = component.transform;
          glyph = this.glyfTable.getGlyphById(component.glyphIndex);
          _matrix = {
            a: 1,
            c: 0,
            e: component.offsetX,
            b: 0,
            d: 1,
            f: component.offsetY
          };
          if (typeof t.scale !== 'undefined') {
            _matrix.a = _matrix.d = t.scale;
          }
          if (typeof t.xScale !== 'undefined') {
            _matrix.a = t.xScale;
          }
          if (typeof t.xScale !== 'undefined') {
            _matrix.d = t.yScale;
          }
          if (typeof t.scale01 !== 'undefined') {
            _matrix.b = t.scale01;
          }
          if (typeof t.scale10 !== 'undefined') {
            _matrix.c = t.scale10;
          }
          if (typeof matrix !== 'undefined') {
            m = matrix;
            _m = _matrix;
            newMatrix = {
              a: m.a * _m.a + m.c * _m.b,
              c: m.a * _m.c + m.c * _m.d,
              e: m.a * _m.e + m.c * _m.f + m.e,
              b: m.b * _m.a + m.d * _m.b,
              d: m.b * _m.c + m.d * _m.d,
              f: m.b * _m.e + m.d * _m.f + m.f
            };
            _matrix = newMatrix;
          }
          _results.push(glyph.toSVGPathString({
            matrix: _matrix,
            relative: relative
          }));
        }
        return _results;
      }).call(this);
      return pathString.join(' ');
    };

    CompositeGlyphData.createFromTTFDataView = function(view, offset, glyphID, glyfTable) {
      var ARGS_ARE_XY_VALUES, ARG_1_AND_2_ARE_WORDS, MORE_COMPONENTS, OVERLAP_COMPOUND, RESERVED, ROUND_XY_TO_GRID, SCALED_COMPONENT_OFFSET, UNSCALED_COMPONENT_OFFSET, USE_MY_METRICS, WE_HAVE_AN_X_AND_Y_SCALE, WE_HAVE_A_SCALE, WE_HAVE_A_TWO_BY_TWO, WE_HAVE_INSTRUCTIONS, component, do_, flags, g, transform;
      ARG_1_AND_2_ARE_WORDS = Math.pow(2, 0);
      ARGS_ARE_XY_VALUES = Math.pow(2, 1);
      ROUND_XY_TO_GRID = Math.pow(2, 2);
      WE_HAVE_A_SCALE = Math.pow(2, 3);
      RESERVED = Math.pow(2, 4);
      MORE_COMPONENTS = Math.pow(2, 5);
      WE_HAVE_AN_X_AND_Y_SCALE = Math.pow(2, 6);
      WE_HAVE_A_TWO_BY_TWO = Math.pow(2, 7);
      WE_HAVE_INSTRUCTIONS = Math.pow(2, 8);
      USE_MY_METRICS = Math.pow(2, 9);
      OVERLAP_COMPOUND = Math.pow(2, 10);
      SCALED_COMPONENT_OFFSET = Math.pow(2, 11);
      UNSCALED_COMPONENT_OFFSET = Math.pow(2, 12);
      view.seek(offset);
      g = new CompositeGlyphData(glyphID, glyfTable);
      g.numberOfContours = view.getShort();
      g.xMin = view.getShort();
      g.yMin = view.getShort();
      g.xMax = view.getShort();
      g.yMax = view.getShort();
      do_ = MORE_COMPONENTS;
      g.components = (function() {
        var _results;
        _results = [];
        while (do_ === MORE_COMPONENTS) {
          component = {
            offsetX: 0,
            offsetY: 0
          };
          component.flags = view.getUshort();
          component.glyphIndex = view.getUshort();
          flags = component.flags;
          if (flags & ARG_1_AND_2_ARE_WORDS) {
            if (flags & ARGS_ARE_XY_VALUES) {
              component.offsetX = view.getShort();
              component.offsetY = view.getShort();
            } else {
              component.points = [view.getShort(), view.getShort()];
            }
          } else {
            if (flags & ARGS_ARE_XY_VALUES) {
              component.offsetX = view.getChar();
              component.offsetY = view.getChar();
            } else {
              component.points = [view.getChar(), view.getChar()];
            }
          }
          component.transform = transform = {};
          if (flags & WE_HAVE_A_SCALE) {
            transform.scale = view.getF2dot14();
          } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
            transform.xScale = view.getF2dot14();
            transform.yScale = view.getF2dot14();
          } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
            transform.xScale = view.getF2dot14();
            transform.scale01 = view.getF2dot14();
            transform.scale10 = view.getF2dot14();
            transform.yScale = view.getF2dot14();
          }
          do_ = flags & MORE_COMPONENTS;
          _results.push(component);
        }
        return _results;
      })();
      return g;
    };

    CompositeGlyphData.createFromJSON = function(json, glyfTable) {
      var g;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      g = new CompositeGlyphData(json.GID, glyfTable);
      g.numberOfContours = json.numberOfContours;
      g.xMin = json.xMin;
      g.yMin = json.yMin;
      g.xMax = json.xMax;
      g.yMax = json.yMax;
      g.components = json.components;
      return g;
    };

    return CompositeGlyphData;

  })();


  Glyph = (function() {

    function Glyph(glyphData, ttf) {
      this.glyphData = glyphData;
      this.GID = glyphData.GID;
      this.type = glyphData.type;
      this.numberOfContours = glyphData.numberOfContours;
      this.xMin = glyphData.xMin;
      this.yMin = glyphData.yMin;
      this.xMax = glyphData.xMax;
      this.yMax = glyphData.yMax;
      this.hmtx = {
        advanceWidth: (ttf.hmtx.hMetrics[this.GID] != null) && ttf.hmtx.hMetrics[this.GID].advanceWidth || ttf.hmtx.hMetrics[ttf.hmtx.hMetrics.length - 1],
        lbs: (ttf.hmtx.hMetrics[this.GID] != null) && ttf.hmtx.hMetrics[this.GID].lsb || ttf.hmtx.leftSideBearing[this.GID - ttf.hmtx.hMetrics.length]
      };
    }

    Glyph.prototype.toSVGPathString = function(options) {
      if (options == null) {
        options = {};
      }
      return this.glyphData.toSVGPathString(options);
    };

    return Glyph;

  })();


  SimpleGlyphData = (function() {

    function SimpleGlyphData(GID, glyfTable) {
      if (GID == null) {
        GID = null;
      }
      if (glyfTable == null) {
        glyfTable = null;
      }
      this.GID = GID;
      this.type = 'simple';
      this.numberOfContours = 0;
      this.xMin = 0;
      this.yMin = 0;
      this.xMax = 0;
      this.yMax = 0;
      this.endPtsOfContours = [];
      this.instructionLength = 0;
      this.instructions = [];
      this.flags = [];
      this.xCoordinates = [];
      this.yCoordinates = [];
      this.glyfTable = glyfTable;
      this._outline = [];
      this.setOutline = function(outline) {
        this._outline = outline != null ? outline : [];
        return this;
      };
      this.getOutline = function() {
        return this._outline;
      };
    }

    SimpleGlyphData.prototype.toSVGPathString = function(options) {
      var after_contour, c, contour, coordinate, currentPoint, distance, end, i, j, k, matrix, midPoint, next, outline, pathString, prev, relative, segment, start, startIndex, _contour, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      matrix = (_ref = options != null ? options.matrix : void 0) != null ? _ref : void 0;
      relative = (_ref1 = options != null ? options.relative : void 0) != null ? _ref1 : false;
      outline = this.getTramsformedOutline(matrix);
      pathString = [];
      for (i = _i = 0, _len = outline.length; _i < _len; i = ++_i) {
        contour = outline[i];
        _contour = [];
        startIndex = 0;
        start = contour[0];
        if (!start.on) {
          if (contour.length > 1) {
            startIndex = 1;
            next = contour[1];
            if (!next.on) {
              _contour.push({
                x: start.x + (next.x - start.x) / 2,
                y: start.y + (next.y - start.y) / 2,
                on: true
              });
            }
          }
        }
        after_contour = [];
        for (j = _j = 0, _len1 = contour.length; _j < _len1; j = ++_j) {
          coordinate = contour[j];
          coordinate = {
            x: coordinate.x,
            y: coordinate.y,
            on: coordinate.on
          };
          if (j < startIndex) {
            after_contour.push(coordinate);
          } else {
            _contour.push(coordinate);
          }
        }
        _contour = _contour.concat(after_contour);
        start = _contour[0];
        end = _contour[_contour.length - 1];
        for (k = _k = 0, _len2 = _contour.length; _k < _len2; k = ++_k) {
          c = _contour[k];
          if (k === 0) {
            pathString.push('M ' + [c.x, c.y].join(','));
            currentPoint = c;
          } else {
            prev = _contour[k - 1];
            distance = {
              x: c.x - prev.x,
              y: c.y - prev.y,
              relX: c.x - currentPoint.x,
              relY: c.y - currentPoint.y
            };
            if (prev.on && c.on) {
              if (distance.y === 0) {
                segment = relative ? 'h ' + distance.relX : 'H ' + c.x;
                pathString.push(segment);
              } else if (distance.x === 0) {
                segment = relative ? 'v ' + distance.relY : 'V ' + c.y;
                pathString.push(segment);
              } else {
                segment = relative ? 'l ' + [distance.relX, distance.relY].join(',') : 'L ' + [c.x, c.y].join(',');
                pathString.push(segment);
              }
              currentPoint = c;
            } else if (prev.on && !c.on) {
              segment = relative ? 'q ' + [distance.relX, distance.relY].join(',') : 'Q ' + [c.x, c.y].join(',');
              pathString.push(segment);
            } else if (!prev.on && !c.on) {
              midPoint = {
                x: prev.x + (distance.x / 2),
                y: prev.y + (distance.y / 2),
                on: true
              };
              segment = relative ? [midPoint.x - currentPoint.x, midPoint.y - currentPoint.y].join(',') + ' t' : [midPoint.x, midPoint.y].join(',') + ' T';
              pathString.push(segment);
              currentPoint = midPoint;
            } else {
              segment = relative ? [distance.relX, distance.relY].join(',') : [c.x, c.y].join(',');
              pathString.push(segment);
              currentPoint = c;
            }
          }
        }
        if (end.on) {
          pathString.push('Z');
        } else if (relative) {
          pathString.push([start.x - currentPoint.x, start.y - currentPoint.y].join(',') + ' Z');
        } else {
          pathString.push([start.x, start.y].join(',') + ' Z');
        }
      }
      return pathString.join(' ');
    };

    SimpleGlyphData.prototype.getTramsformedOutline = function(matrix) {
      var contour, coordinate, _i, _len, _ref, _results;
      if (typeof matrix === 'undefined') {
        matrix = {
          a: 1,
          c: 0,
          e: 0,
          b: 0,
          d: 1,
          f: 0
        };
      }
      _ref = this.getOutline();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        contour = _ref[_i];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = contour.length; _j < _len1; _j++) {
            coordinate = contour[_j];
            _results1.push({
              x: matrix.a * coordinate.x + matrix.c * coordinate.y + matrix.e,
              y: matrix.b * coordinate.x + matrix.d * coordinate.y + matrix.f,
              on: coordinate.on
            });
          }
          return _results1;
        })());
      }
      return _results;
    };

    SimpleGlyphData.createFromTTFDataView = function(view, offset, glyphID, glyfTable) {
      var ON_CURVE, POSITIVE_X_SHORT, POSITIVE_Y_SHORT, REPEAT, X_IS_SAME, X_SHORT, Y_IS_SAME, Y_SHORT, contour, endPtOfcountour, flag, flags, g, i, j, numRepeat, numberOfCoordinates, outline, relX, relY, startPtOfContour, x, y, _i;
      ON_CURVE = Math.pow(2, 0);
      X_SHORT = Math.pow(2, 1);
      Y_SHORT = Math.pow(2, 2);
      REPEAT = Math.pow(2, 3);
      X_IS_SAME = Math.pow(2, 4);
      POSITIVE_X_SHORT = Math.pow(2, 4);
      Y_IS_SAME = Math.pow(2, 5);
      POSITIVE_Y_SHORT = Math.pow(2, 5);
      view.seek(offset);
      g = new SimpleGlyphData(glyphID, glyfTable);
      g.numberOfContours = view.getShort();
      if (g.numberOfContours === 0) {
        return g;
      }
      g.xMin = view.getShort();
      g.yMin = view.getShort();
      g.xMax = view.getShort();
      g.yMax = view.getShort();
      g.endPtsOfContours = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = g.numberOfContours; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(view.getUshort());
        }
        return _results;
      })();
      numberOfCoordinates = g.endPtsOfContours[g.endPtsOfContours.length - 1] + 1;
      g.instructionLength = view.getUshort();
      if (g.instructionLength > 0) {
        g.instructions = (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 1, _ref = g.instructionLength; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
            _results.push(view.getByte());
          }
          return _results;
        })();
      }
      flags = [];
      i = 0;
      while (i < numberOfCoordinates) {
        flag = view.getByte();
        flags.push(flag);
        i++;
        if (flag & REPEAT) {
          numRepeat = view.getByte();
          for (j = _i = 1; 1 <= numRepeat ? _i <= numRepeat : _i >= numRepeat; j = 1 <= numRepeat ? ++_i : --_i) {
            if (i < numberOfCoordinates) {
              flags.push(flag);
              i++;
            }
          }
        }
      }
      g.flags = flags;
      g.xCoordinates = (function() {
        var _j, _len, _results;
        _results = [];
        for (_j = 0, _len = flags.length; _j < _len; _j++) {
          flag = flags[_j];
          x = 0;
          if (flag & X_SHORT) {
            _results.push(x = (flag & POSITIVE_X_SHORT ? 1 : -1) * view.getByte());
          } else {
            _results.push(x = flag & X_IS_SAME ? 0 : view.getShort());
          }
        }
        return _results;
      })();
      g.yCoordinates = (function() {
        var _j, _len, _results;
        _results = [];
        for (_j = 0, _len = flags.length; _j < _len; _j++) {
          flag = flags[_j];
          y = 0;
          if (flag & Y_SHORT) {
            _results.push(y = (flag & POSITIVE_Y_SHORT ? 1 : -1) * view.getByte());
          } else {
            _results.push(y = flag & Y_IS_SAME ? 0 : view.getShort());
          }
        }
        return _results;
      })();
      startPtOfContour = x = y = 0;
      outline = (function() {
        var _j, _len, _ref, _results;
        _ref = g.endPtsOfContours;
        _results = [];
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          endPtOfcountour = _ref[_j];
          contour = (function() {
            var _k, _results1;
            _results1 = [];
            for (i = _k = startPtOfContour; startPtOfContour <= endPtOfcountour ? _k <= endPtOfcountour : _k >= endPtOfcountour; i = startPtOfContour <= endPtOfcountour ? ++_k : --_k) {
              x += relX = g.xCoordinates[i];
              y += relY = g.yCoordinates[i];
              _results1.push({
                x: x,
                y: y,
                on: flags[i] & ON_CURVE === ON_CURVE
              });
            }
            return _results1;
          })();
          startPtOfContour = endPtOfcountour + 1;
          _results.push(contour);
        }
        return _results;
      })();
      g.setOutline(outline);
      return g;
    };

    SimpleGlyphData.createFromJSON = function(json, glyfTable) {
      var g;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      g = new SimpleGlyphData(json.GID, glyfTable);
      g.numberOfContours = json.numberOfContours;
      g.xMin = json.xMin;
      g.yMin = json.yMin;
      g.xMax = json.xMax;
      g.yMax = json.yMax;
      g.endPtsOfContours = json.endPtsOfContours;
      g.instructionLength = json.instructionLength;
      g.instructions = json.instructions;
      g.flags = json.flags;
      g.xCoordinates = json.xCoordinates;
      g.yCoordinates = json.yCoordinates;
      g.setOutline(json._outline);
      return g;
    };

    return SimpleGlyphData;

  })();




  GlyfTable = (function() {

    function GlyfTable() {
      this.glyphs = [];
    }

    GlyfTable.prototype.getGlyphById = function(id) {
      if (typeof this.glyphs[id] !== 'undefined') {
        return this.glyphs[id];
      } else {
        return false;
      }
    };

    GlyfTable.createFromTTFDataView = function(view, offset, ttf) {
      var glyfTable, glyphLocation, i, loca, location;
      loca = ttf.loca;
      view.seek(offset);
      glyfTable = new GlyfTable();
      glyfTable.glyphs = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = loca.offsets.length - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          location = loca.offsets[i];
          glyphLocation = location + offset;
          if ((loca.offsets[i + 1] != null) && location === loca.offsets[i + 1]) {
            _results.push(new SimpleGlyphData(i, glyfTable));
          } else if (view.getShort(glyphLocation) >= 0) {
            _results.push(SimpleGlyphData.createFromTTFDataView(view, glyphLocation, i, glyfTable));
          } else {
            _results.push(CompositeGlyphData.createFromTTFDataView(view, glyphLocation, i, glyfTable));
          }
        }
        return _results;
      })();
      return glyfTable;
    };

    GlyfTable.createFromJSON = function(json) {
      var glyfTable, glyph, _i, _len, _ref;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      glyfTable = new GlyfTable();
      _ref = json.glyphs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        glyph = _ref[_i];
        if (glyph.type === 'simple') {
          glyfTable.glyphs.push(SimpleGlyphData.createFromJSON(glyph, glyfTable));
        } else {
          glyfTable.glyphs.push(CompositeGlyphData.createFromJSON(glyph, glyfTable));
        }
      }
      return glyfTable;
    };

    return GlyfTable;

  })();


  HeadTable = (function() {

    function HeadTable() {
      this.version = 0;
      this.fontRevision = 0;
      this.checkSumAdjustment = '0x00000000';
      this.magicNumber = '0x5f0f3cf5';
      this.flags = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.unitsPerEm = 0;
      this.created = new Date();
      this.modified = new Date();
      this.xMin = 0;
      this.yMin = 0;
      this.xMax = 0;
      this.yMax = 0;
      this.macStyle = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.lowestRecPPEM = 0;
      this.fontDirectionHint = 2;
      this.indexToLocFormat = 0;
      this.glyphDataFormat = 0;
    }

    HeadTable.prototype.isLocaLong = function() {
      return this.indexToLocFormat === 1;
    };

    HeadTable.createFromTTFDataView = function(view, offset) {
      var head;
      view.seek(offset);
      head = new HeadTable();
      head.version = view.getFixed();
      head.fontRevision = view.getFixed();
      head.checkSumAdjustment = '0x' + view.getUlong(offset + 8).toString(16);
      head.magicNumber = '0x' + view.getUlong().toString(16);
      head.flags = view.getUshortFlags();
      head.unitsPerEm = view.getUshort();
      head.created = view.getLongDateTime();
      head.modified = view.getLongDateTime();
      head.xMin = view.getShort();
      head.yMin = view.getShort();
      head.xMax = view.getShort();
      head.yMax = view.getShort();
      head.macStyle = view.getUshortFlags();
      head.lowestRecPPEM = view.getUshort();
      head.fontDirectionHint = view.getShort();
      head.indexToLocFormat = view.getShort();
      head.glyphDataFormat = view.getShort();
      return head;
    };

    HeadTable.createFromJSON = function(json) {
      var head;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      head = new HeadTable();
      head.version = json.version;
      head.fontRevision = json.fontRevision;
      head.checkSumAdjustment = json.checkSumAdjustment;
      head.magicNumber = json.magicNumber;
      head.flags = json.flags;
      head.unitsPerEm = json.unitsPerEm;
      head.created = new Date(json.created);
      head.modified = new Date(json.modified);
      head.xMin = json.xMin;
      head.yMin = json.yMin;
      head.xMax = json.xMax;
      head.yMax = json.yMax;
      head.macStyle = json.macStyle;
      head.lowestRecPPEM = json.lowestRecPPEM;
      head.fontDirectionHint = json.fontDirectionHint;
      head.indexToLocFormat = json.indexToLocFormat;
      head.glyphDataFormat = json.glyphDataFormat;
      return head;
    };

    return HeadTable;

  })();


  HheaTable = (function() {

    function HheaTable() {
      this.version = 0;
      this.ascender = 0;
      this.descender = 0;
      this.lineGap = 0;
      this.advanceWidthMax = 0;
      this.minLeftSideBearing = 0;
      this.minRightSideBearing = 0;
      this.xMaxExtent = 0;
      this.caretSlopeRise = 0;
      this.caretSlopeRun = 0;
      this.caretOffset = 0;
      this.reserved_0 = 0;
      this.reserved_1 = 0;
      this.reserved_2 = 0;
      this.reserved_3 = 0;
      this.metricDataFormat = 0;
      this.numberOfHMetrics = 0;
    }

    HheaTable.createFromTTFDataView = function(view, offset, ttf) {
      var hhea;
      view.seek(offset);
      hhea = new HheaTable();
      hhea.version = view.getFixed();
      hhea.ascender = view.getFWord();
      hhea.descender = view.getFWord();
      hhea.lineGap = view.getFWord();
      hhea.advanceWidthMax = view.getUFWord();
      hhea.minLeftSideBearing = view.getFWord();
      hhea.minRightSideBearing = view.getFWord();
      hhea.xMaxExtent = view.getFWord();
      hhea.caretSlopeRise = view.getShort();
      hhea.caretSlopeRun = view.getShort();
      hhea.caretOffset = view.getShort();
      hhea.reserved_0 = view.getShort();
      hhea.reserved_1 = view.getShort();
      hhea.reserved_2 = view.getShort();
      hhea.reserved_3 = view.getShort();
      hhea.metricDataFormat = view.getShort();
      hhea.numberOfHMetrics = view.getUshort();
      return hhea;
    };

    HheaTable.createFromJSON = function(json) {
      var hhea;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      hhea = new HheaTable();
      hhea.version = json.version;
      hhea.ascender = json.ascender;
      hhea.descender = json.descender;
      hhea.lineGap = json.lineGap;
      hhea.advanceWidthMax = json.advanceWidthMax;
      hhea.minLeftSideBearing = json.minLeftSideBearing;
      hhea.minRightSideBearing = json.minRightSideBearing;
      hhea.xMaxExtent = json.xMaxExtent;
      hhea.caretSlopeRise = json.caretSlopeRise;
      hhea.caretSlopeRun = json.caretSlopeRun;
      hhea.caretOffset = json.caretOffset;
      hhea.reserved_0 = json.reserved_0;
      hhea.reserved_1 = json.reserved_1;
      hhea.reserved_2 = json.reserved_2;
      hhea.reserved_3 = json.reserved_3;
      hhea.metricDataFormat = json.metricDataFormat;
      hhea.numberOfHMetrics = json.numberOfHMetrics;
      return hhea;
    };

    return HheaTable;

  })();


  HmtxTable = (function() {

    function HmtxTable() {
      this.hMetrics = [];
      this.leftSideBearing = [];
    }

    HmtxTable.createFromTTFDataView = function(view, offset, ttf) {
      var hmtx, i, lsbNum, numGlyphs, numberOfHMetrics;
      numberOfHMetrics = ttf.hhea.numberOfHMetrics;
      numGlyphs = ttf.maxp.numGlyphs;
      lsbNum = numGlyphs - numberOfHMetrics;
      view.seek(offset);
      hmtx = new HmtxTable();
      hmtx.hMetrics = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= numberOfHMetrics ? _i <= numberOfHMetrics : _i >= numberOfHMetrics; i = 1 <= numberOfHMetrics ? ++_i : --_i) {
          _results.push({
            advanceWidth: view.getUshort(),
            lsb: view.getShort()
          });
        }
        return _results;
      })();
      if (lsbNum > 0) {
        hmtx.leftSideBearing = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 1; 1 <= lsbNum ? _i <= lsbNum : _i >= lsbNum; i = 1 <= lsbNum ? ++_i : --_i) {
            _results.push(view.getShort());
          }
          return _results;
        })();
      }
      return hmtx;
    };

    HmtxTable.createFromJSON = function(json) {
      var hmtx;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      hmtx = new HmtxTable();
      hmtx.hMetrics = json.hMetrics;
      hmtx.leftSideBearing = json.leftSideBearing;
      return hmtx;
    };

    return HmtxTable;

  })();


  LocaTable = (function() {

    function LocaTable() {
      this.offsets = [];
    }

    LocaTable.createFromTTFDataView = function(view, offset, ttf) {
      var i, loca, long, numGlyphs;
      numGlyphs = ttf.getNumGlyphs();
      long = ttf.isLocaLong();
      view.seek(offset);
      loca = new LocaTable();
      loca.offsets = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= numGlyphs ? _i <= numGlyphs : _i >= numGlyphs; i = 0 <= numGlyphs ? ++_i : --_i) {
          if (long) {
            _results.push(view.getUlong());
          } else {
            _results.push(view.getUshort() * 2);
          }
        }
        return _results;
      })();
      return loca;
    };

    LocaTable.createFromJSON = function(json) {
      var loca;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      loca = new LocaTable();
      loca.offsets = json.offsets;
      return loca;
    };

    return LocaTable;

  })();


  MaxpTable = (function() {

    function MaxpTable() {
      this.version = 0;
      this.numGlyphs = 0;
      this.maxPoints = 0;
      this.maxContours = 0;
      this.maxCompositPoints = 0;
      this.maxCompositContours = 0;
      this.maxZones = 0;
      this.maxTwilightPoints = 0;
      this.maxStorage = 0;
      this.maxFunctionDefs = 0;
      this.maxInstructionDefs = 0;
      this.maxStackElements = 0;
      this.maxSizeOfInstructions = 0;
      this.maxComponentElements = 0;
      this.maxComponentDepth = 0;
    }

    MaxpTable.createFromTTFDataView = function(view, offset) {
      var maxp;
      view.seek(offset);
      maxp = new MaxpTable();
      maxp.version = view.getFixed();
      maxp.numGlyphs = view.getUshort();
      maxp.maxPoints = view.getUshort();
      maxp.maxContours = view.getUshort();
      maxp.maxCompositPoints = view.getUshort();
      maxp.maxCompositContours = view.getUshort();
      maxp.maxZones = view.getUshort();
      maxp.maxTwilightPoints = view.getUshort();
      maxp.maxStorage = view.getUshort();
      maxp.maxFunctionDefs = view.getUshort();
      maxp.maxInstructionDefs = view.getUshort();
      maxp.maxStackElements = view.getUshort();
      maxp.maxSizeOfInstructions = view.getUshort();
      maxp.maxComponentElements = view.getUshort();
      maxp.maxComponentDepth = view.getUshort();
      return maxp;
    };

    MaxpTable.createFromJSON = function(json) {
      var maxp;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      maxp = new MaxpTable();
      maxp.version = json.version;
      maxp.numGlyphs = json.numGlyphs;
      maxp.maxPoints = json.maxPoints;
      maxp.maxContours = json.maxContours;
      maxp.maxCompositPoints = json.maxCompositPoints;
      maxp.maxCompositContours = json.maxCompositContours;
      maxp.maxZones = json.maxZones;
      maxp.maxTwilightPoints = json.maxTwilightPoints;
      maxp.maxStorage = json.maxStorage;
      maxp.maxFunctionDefs = json.maxFunctionDefs;
      maxp.maxInstructionDefs = json.maxInstructionDefs;
      maxp.maxStackElements = json.maxStackElements;
      maxp.maxSizeOfInstructions = json.maxSizeOfInstructions;
      maxp.maxComponentElements = json.maxComponentElements;
      maxp.maxComponentDepth = json.maxComponentDepth;
      return maxp;
    };

    return MaxpTable;

  })();


  OS_2Table = (function() {

    function OS_2Table() {
      this.version = 0;
      this.xAvgCharWidth = 0;
      this.usWeightClass = 400;
      this.usWidthClass = 5;
      this.fsType = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.ySubscriptXSize = 0;
      this.ySubscriptYSize = 0;
      this.ySubscriptXOffset = 0;
      this.ySubscriptYOffset = 0;
      this.ySuperscriptXSize = 0;
      this.ySuperscriptYSize = 0;
      this.ySuperscriptXOffset = 0;
      this.ySuperscriptYOffset = 0;
      this.yStrikeoutSize = 0;
      this.yStrikeoutPosition = 0;
      this.sFamilyClass = {
        "class": 0,
        subclass: 0
      };
      this.panose = {
        bFamilyType: 0,
        bSerifStyle: 0,
        bWeight: 0,
        bProportion: 0,
        bContrast: 0,
        bStrokeVariation: 0,
        bArmStyle: 0,
        bLetterForm: 0,
        bMidline: 0,
        bXHeight: 0
      };
      this.ulUnicodeRange1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.ulUnicodeRange2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.ulUnicodeRange3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.ulUnicodeRange4 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.achVendID = '';
      this.fsSelection = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.usFirstCharIndex = 0;
      this.usLastCharIndex = 0;
      this.sTypoAscender = 0;
      this.sTypoDescender = 0;
      this.sTypoLineGap = 0;
      this.usWinAscent = 0;
      this.usWinDescent = 0;
      this.ulCodePageRange1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.ulCodePageRange2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.sxHeight = void 0;
      this.sCapHeight = void 0;
      this.usDefaultChar = void 0;
      this.usBreakChar = void 0;
      this.usMaxContext = void 0;
    }

    OS_2Table.prototype.getUsWeightClassString = function() {
      return OS_2Table.US_WEIGHT_CLASS[this.usWeightClass];
    };

    OS_2Table.prototype.getUsWidthClassString = function() {
      return OS_2Table.US_WIDTH_CLASS[this.usWidthClass];
    };

    OS_2Table.prototype.getFamilyClass = function() {
      if (typeof OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]] !== 'undefined') {
        return OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]].name;
      } else {
        return false;
      }
    };

    OS_2Table.prototype.getFamilySubclass = function() {
      if (typeof OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]] !== 'undefined' && typeof OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]].subclass !== 'undefined') {
        if (typeof OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]].subclass[this.sFamilyClass.subclass] !== 'undefined') {
          return OS_2Table.IBM_FONT_CLASS[this.sFamilyClass["class"]].subclass[this.sFamilyClass.subclass];
        } else {
          return false;
        }
      } else {
        return false;
      }
    };

    OS_2Table.US_WEIGHT_CLASS = {
      100: 'Thin',
      200: 'Extra-light',
      300: 'Light',
      400: 'Normal',
      500: 'Medium',
      600: 'Semi-bold',
      700: 'Bold',
      800: 'Extra-bold',
      900: 'Black'
    };

    OS_2Table.US_WIDTH_CLASS = {
      1: 'Ultra-condensed',
      2: 'Extra-condensed',
      3: 'Condensed',
      4: 'Semi-condensed',
      5: 'Medium',
      6: 'Semi-expanded',
      7: 'Expanded',
      8: 'Extra-expanded',
      9: 'Ultra-expanded'
    };

    OS_2Table.IBM_FONT_CLASS = {
      0: {
        name: 'No Classification'
      },
      1: {
        name: 'Oldstyle Serifs',
        subclass: {
          0: 'No Classification',
          1: 'IBM Rounded Legibility',
          2: 'Garalde',
          3: 'Venetian',
          4: 'Modified Venetian',
          5: 'Dutch Modern',
          6: 'Dutch Traditional',
          7: 'Contemporary',
          8: 'Calligraphic',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      2: {
        name: 'Transitional Serifs',
        subclass: {
          0: 'No Classification',
          1: 'Direct Line',
          2: 'Script',
          3: '(reserved for future use)',
          4: '(reserved for future use)',
          5: '(reserved for future use)',
          6: '(reserved for future use)',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      3: {
        name: 'Modern Serifs',
        subclass: {
          0: 'No Classification',
          1: 'Italian',
          2: 'Script',
          3: '(reserved for future use)',
          4: '(reserved for future use)',
          5: '(reserved for future use)',
          6: '(reserved for future use)',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      4: {
        name: 'Clarendon Serifs',
        subclass: {
          0: 'No Classification',
          1: 'Clarendon',
          2: 'Modern',
          3: 'Traditional',
          4: 'Newspaper',
          5: 'Stub Serif',
          6: 'Monotone',
          7: 'Typewriter',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      5: {
        name: 'Slab Serifs',
        subclass: {
          0: 'No Classification',
          1: 'Monotone',
          2: 'Humanist',
          3: 'Geometric',
          4: 'Swiss',
          5: 'Typewriter',
          6: '(reserved for future use)',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      6: {
        name: '(reserved for future use)'
      },
      7: {
        name: 'Freeform Serifs',
        subclass: {
          0: 'No Classification',
          1: '(reserved for future use)',
          2: '(reserved for future use)',
          3: '(reserved for future use)',
          4: '(reserved for future use)',
          5: '(reserved for future use)',
          6: '(reserved for future use)',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      8: {
        name: 'Sans Serifs',
        subclass: {
          0: 'No Classification',
          1: 'IBM Neo-grotesque Gothic',
          2: 'Humanist',
          3: 'Low-x Round Geometric',
          4: 'High-x Round Geometric',
          5: 'Neo-grotesque Gothic',
          6: 'Modified Neo-grotesque Gothic',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: 'Typewriter Gothic',
          10: 'Matrix',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      9: {
        name: 'Ornamentals',
        subclass: {
          0: 'No Classification',
          1: 'Engraver',
          2: 'Black Letter',
          3: 'Decorative',
          4: 'Three Dimensional',
          5: '(reserved for future use)',
          6: '(reserved for future use)',
          7: '(reserved for future use)',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      10: {
        name: 'Scripts',
        subclass: {
          0: 'No Classification',
          1: 'Uncial',
          2: 'Brush Joined',
          3: 'Formal Joined',
          4: 'Monotone Joined',
          5: 'Calligraphic',
          6: 'Brush Unjoined',
          7: 'Formal Unjoined',
          8: 'Monotone Unjoined',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      11: {
        name: '(reserved for future use)'
      },
      12: {
        name: 'Symbolic',
        subclass: {
          0: 'No Classification',
          1: '(reserved for future use)',
          2: '(reserved for future use)',
          3: 'Mixed Serif',
          4: '(reserved for future use)',
          5: '(reserved for future use)',
          6: 'Oldstyle Serif',
          7: 'Neo-grotesque Sans Serif',
          8: '(reserved for future use)',
          9: '(reserved for future use)',
          10: '(reserved for future use)',
          11: '(reserved for future use)',
          12: '(reserved for future use)',
          13: '(reserved for future use)',
          14: '(reserved for future use)',
          15: 'Miscellaneous'
        }
      },
      13: {
        name: 'Reserved'
      },
      14: {
        name: 'Reserved'
      }
    };

    OS_2Table.PANOSE = {
      FAMILY_TYPE: {
        0: 'Any',
        1: 'No Fit',
        2: 'Text and Display',
        3: 'Script',
        4: 'Decorative',
        5: 'Pictorial'
      },
      SERIF_STYLE: {
        0: 'Any',
        1: 'No Fit',
        2: 'Cove',
        3: 'Obtuse Cove',
        4: 'Square Cove',
        5: 'Obtuse Square Cove',
        6: 'Square',
        7: 'Thin',
        8: 'Bone',
        9: 'Exaggerated',
        10: 'Triangle',
        11: 'Normal Sans',
        12: 'Obtuse Sans',
        13: 'Perp Sans',
        14: 'Flared',
        15: 'Rounded'
      },
      WEIGHT: {
        0: 'Any',
        1: 'No Fit',
        2: 'Very Light',
        3: 'Light',
        4: 'Thin',
        5: 'Book',
        6: 'Medium',
        7: 'Demi',
        8: 'Bold',
        9: 'Heavy',
        10: 'Black',
        11: 'Nord'
      },
      PROPORTION: {
        0: 'Any',
        1: 'No Fit',
        2: 'Old Style',
        3: 'Modern',
        4: 'Even Width',
        5: 'Expanded',
        6: 'Condensed',
        7: 'Very Expanded',
        8: 'Very Condensed',
        9: 'Monospaced'
      },
      CONTRAST: {
        0: 'Any',
        1: 'No Fit',
        2: 'None',
        3: 'Very Low',
        4: 'Low',
        5: 'Medium Low',
        6: 'Medium',
        7: 'Medium High',
        8: 'High',
        9: 'Very High'
      },
      STROKE_VARIATION: {
        0: 'Any',
        1: 'No Fit',
        2: 'Gradual/Diagonal',
        3: 'Gradual/Transitional',
        4: 'Gradual/Vertical',
        5: 'Gradual/Horizontal',
        6: 'Rapid/Vertical',
        7: 'Rapid/Horizontal',
        8: 'Instant/Vertical'
      },
      ARM_STYLE: {
        0: 'Any',
        1: 'No Fit',
        2: 'Straight Arms/Horizontal',
        3: 'Straight Arms/Wedge',
        4: 'Straight Arms/Vertical',
        5: 'Straight Arms/Single Serif',
        6: 'Straight Arms/Double Serif',
        7: 'Non-Straight Arms/Horizontal',
        8: 'Non-Straight Arms/Wedge',
        9: 'Non-Straight Arms/Vertical',
        10: 'Non-Straight Arms/Single Serif',
        11: 'Non-Straight Arms/Double Serif'
      },
      LETTERFORM: {
        0: 'Any',
        1: 'No Fit',
        2: 'Normal/Contact',
        3: 'Normal/Weighted',
        4: 'Normal/Boxed',
        5: 'Normal/Flattened',
        6: 'Normal/Rounded',
        7: 'Normal/Off Center',
        8: 'Normal/Square',
        9: 'Oblique/Contact',
        10: 'Oblique/Weighted',
        11: 'Oblique/Boxed',
        12: 'Oblique/Flattened',
        13: 'Oblique/Rounded',
        14: 'Oblique/Off Center',
        15: 'Oblique/Square'
      },
      MIDLINE: {
        0: 'Any',
        1: 'No Fit',
        2: 'Standard/Trimmed',
        3: 'Standard/Pointed',
        4: 'Standard/Serifed',
        5: 'High/Trimmed',
        6: 'High/Pointed',
        7: 'High/Serifed',
        8: 'Constant/Trimmed',
        9: 'Constant/Pointed',
        10: 'Constant/Serifed',
        11: 'Low/Trimmed',
        12: 'Low/Pointed',
        13: 'Low/Serifed'
      },
      X_HEIGHT: {
        0: 'Any',
        1: 'No Fit',
        2: 'Constant/Small',
        3: 'Constant/Standard',
        4: 'Constant/Large',
        5: 'Ducking/Small',
        6: 'Ducking/Standard',
        7: 'Ducking/Large'
      }
    };

    OS_2Table.UNICODE_RANGE = {
      0: 'Basic Latin',
      1: 'Latin-1 Supplement',
      2: 'Latin Extended-A',
      3: 'Latin Extended-B',
      4: 'IPA Extensions',
      5: 'Spacing Modifier Letters',
      6: 'Combining Diacritical Marks',
      7: 'Basic Greek',
      8: 'Greek Symbols and Coptic',
      9: 'Cyrillic',
      10: 'Armenian',
      11: 'Basic Hebrew',
      12: 'Hebrew Extended (A and B blocks combined)',
      13: 'Basic Arabic',
      14: 'Arabic Extended',
      15: 'Devanagari',
      16: 'Bengali',
      17: 'Gurmukhi',
      18: 'Gujarati',
      19: 'Oriya',
      20: 'Tamil',
      21: 'Telugu',
      22: 'Kannada',
      23: 'Malayalam',
      24: 'Thai',
      25: 'Lao',
      26: 'Basic Georgian',
      27: 'Georgian Extended',
      28: 'Hangul Jamo',
      29: 'Latin Extended Additional',
      30: 'Greek Extended',
      31: 'General Punctuation',
      32: 'Superscripts And Subscripts',
      33: 'Currency Symbols',
      34: 'Combining Diacritical Marks For Symbols',
      35: 'Letterlike Symbols',
      36: 'Number Forms',
      37: 'Arrows',
      38: 'Mathematical Operators',
      39: 'Miscellaneous Technical',
      40: 'Control Pictures',
      41: 'Optical Character Recognition',
      42: 'Enclosed Alphanumerics',
      43: 'Box Drawing',
      44: 'Block Elements',
      45: 'Geometric Shapes',
      46: 'Miscellaneous Symbols',
      47: 'Dingbats',
      48: 'CJK Symbols And Punctuation',
      49: 'Hiragana',
      50: 'Katakana',
      51: 'Bopomofo',
      52: 'Hangul Compatibility Jamo',
      53: 'CJK Miscellaneous',
      54: 'Enclosed CJK Letters And Months',
      55: 'CJK Compatibility',
      56: 'Hangul',
      57: 'Reserved for Unicode SubRanges',
      58: 'Reserved for Unicode SubRanges',
      59: 'CJK Unified Ideographs',
      60: 'Private Use Area',
      61: 'CJK Compatibility Ideographs',
      62: 'Alphabetic Presentation Forms',
      63: 'Arabic Presentation Forms-A',
      64: 'Combining Half Marks',
      65: 'CJK Compatibility Forms',
      66: 'Small Form Variants',
      67: 'Arabic Presentation Forms-B',
      68: 'Halfwidth And Fullwidth Forms',
      69: 'Specials'
    };

    OS_2Table.UL_CODE_PAGE_RANGE = {
      0: {
        codePage: 1252,
        description: 'Latin 1'
      },
      1: {
        codePage: 1250,
        description: 'Latin 2: Eastern Europe'
      },
      2: {
        codePage: 1251,
        description: 'Cyrillic'
      },
      3: {
        codePage: 1253,
        description: 'Greek'
      },
      4: {
        codePage: 1254,
        description: 'Turkish'
      },
      5: {
        codePage: 1255,
        description: 'Hebrew'
      },
      6: {
        codePage: 1256,
        description: 'Arabic'
      },
      7: {
        codePage: 1257,
        description: 'Windows Baltic'
      },
      16: {
        codePage: 874,
        description: 'Thai'
      },
      17: {
        codePage: 932,
        description: 'JIS/Japan'
      },
      18: {
        codePage: 936,
        description: 'Chinese: Simplified chars--PRC and Singapore'
      },
      19: {
        codePage: 949,
        description: 'Korean Wansung'
      },
      20: {
        codePage: 950,
        description: 'Chinese: Traditional chars--Taiwan and Hong Kong'
      },
      21: {
        codePage: 1361,
        description: 'Korean Johab'
      },
      29: {
        codePage: null,
        description: 'Macintosh Character Set (US Roman)'
      },
      30: {
        codePage: null,
        description: 'OEM Character Set'
      },
      31: {
        codePage: null,
        description: 'Symbol Character Set'
      },
      48: {
        codePage: 869,
        description: 'IBM Greek'
      },
      49: {
        codePage: 866,
        description: 'MS-DOS Russian'
      },
      50: {
        codePage: 865,
        description: 'MS-DOS Nordic'
      },
      51: {
        codePage: 864,
        description: 'Arabic'
      },
      52: {
        codePage: 863,
        description: 'MS-DOS Canadian French'
      },
      53: {
        codePage: 862,
        description: 'Hebrew'
      },
      54: {
        codePage: 861,
        description: 'MS-DOS Icelandic'
      },
      55: {
        codePage: 860,
        description: 'MS-DOS Portuguese'
      },
      56: {
        codePage: 857,
        description: 'IBM Turkish'
      },
      57: {
        codePage: 855,
        description: 'IBM Cyrillic; primarily Russian'
      },
      58: {
        codePage: 852,
        description: 'Latin 2'
      },
      59: {
        codePage: 775,
        description: 'MS-DOS Baltic'
      },
      60: {
        codePage: 737,
        description: 'Greek; former 437 G'
      },
      61: {
        codePage: 708,
        description: 'Arabic; ASMO 708'
      },
      62: {
        codePage: 850,
        description: 'WE/Latin 1'
      },
      63: {
        codePage: 437,
        description: 'US'
      }
    };

    OS_2Table.createFromTTFDataView = function(view, offset, ttf) {
      var OS2;
      view.seek(offset);
      OS2 = new OS_2Table();
      OS2.version = view.getUshort();
      OS2.xAvgCharWidth = view.getShort();
      OS2.usWeightClass = view.getUshort();
      OS2.usWidthClass = view.getUshort();
      OS2.fsType = view.getUshortFlags();
      OS2.ySubscriptXSize = view.getShort();
      OS2.ySubscriptYSize = view.getShort();
      OS2.ySubscriptXOffset = view.getShort();
      OS2.ySubscriptYOffset = view.getShort();
      OS2.ySuperscriptXSize = view.getShort();
      OS2.ySuperscriptYSize = view.getShort();
      OS2.ySuperscriptXOffset = view.getShort();
      OS2.ySuperscriptYOffset = view.getShort();
      OS2.yStrikeoutSize = view.getShort();
      OS2.yStrikeoutPosition = view.getShort();
      OS2.sFamilyClass["class"] = view.getByte();
      OS2.sFamilyClass.subclass = view.getByte();
      OS2.panose.bFamilyType = view.getByte();
      OS2.panose.bSerifStyle = view.getByte();
      OS2.panose.bWeight = view.getByte();
      OS2.panose.bProportion = view.getByte();
      OS2.panose.bContrast = view.getByte();
      OS2.panose.bStrokeVariation = view.getByte();
      OS2.panose.bArmStyle = view.getByte();
      OS2.panose.bLetterForm = view.getByte();
      OS2.panose.bMidline = view.getByte();
      OS2.panose.bXHeight = view.getByte();
      OS2.ulUnicodeRange1 = view.getUlongFlags();
      if (OS2.version > 0) {
        OS2.ulUnicodeRange2 = view.getUlongFlags();
        OS2.ulUnicodeRange3 = view.getUlongFlags();
        OS2.ulUnicodeRange4 = view.getUlongFlags();
      }
      OS2.achVendID = view.getString(4);
      OS2.fsSelection = view.getUshortFlags();
      OS2.usFirstCharIndex = view.getUshort();
      OS2.usLastCharIndex = view.getUshort();
      OS2.sTypoAscender = view.getShort();
      OS2.sTypoDescender = view.getShort();
      OS2.sTypoLineGap = view.getShort();
      OS2.usWinAscent = view.getUshort();
      OS2.usWinDescent = view.getUshort();
      if (OS2.version > 0) {
        OS2.ulCodePageRange1 = view.getUlongFlags();
        OS2.ulCodePageRange2 = view.getUlongFlags();
      }
      if (OS2.version > 1) {
        OS2.sxHeight = view.getShort();
        OS2.sCapHeight = view.getShort();
        OS2.usDefaultChar = view.getUshort();
        OS2.usBreakChar = view.getUshort();
        OS2.usMaxContext = view.getUshort();
      }
      return OS2;
    };

    OS_2Table.createFromJSON = function(json) {
      var OS2;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      OS2 = new OS_2Table();
      OS2.version = json.version;
      OS2.xAvgCharWidth = json.xAvgCharWidth;
      OS2.xAvgCharWidth = json.xAvgCharWidth;
      OS2.usWeightClass = json.usWeightClass;
      OS2.usWidthClass = json.usWidthClass;
      OS2.fsType = json.fsType;
      OS2.ySubscriptXSize = json.ySubscriptXSize;
      OS2.ySubscriptYSize = json.ySubscriptYSize;
      OS2.ySubscriptXOffset = json.ySubscriptXOffset;
      OS2.ySubscriptYOffset = json.ySubscriptYOffset;
      OS2.ySuperscriptXSize = json.ySuperscriptXSize;
      OS2.ySuperscriptYSize = json.ySuperscriptYSize;
      OS2.ySuperscriptXOffset = json.ySuperscriptXOffset;
      OS2.ySuperscriptYOffset = json.ySuperscriptYOffset;
      OS2.yStrikeoutSize = json.yStrikeoutSize;
      OS2.yStrikeoutPosition = json.yStrikeoutPosition;
      OS2.sFamilyClass = json.sFamilyClass;
      OS2.panose = json.panose;
      OS2.ulUnicodeRange1 = json.ulUnicodeRange1;
      OS2.ulUnicodeRange2 = json.ulUnicodeRange2;
      OS2.ulUnicodeRange3 = json.ulUnicodeRange3;
      OS2.ulUnicodeRange4 = json.ulUnicodeRange4;
      OS2.achVendID = json.achVendID;
      OS2.fsSelection = json.fsSelection;
      OS2.usFirstCharIndex = json.usFirstCharIndex;
      OS2.usLastCharIndex = json.usLastCharIndex;
      OS2.sTypoAscender = json.sTypoAscender;
      OS2.sTypoDescender = json.sTypoDescender;
      OS2.sTypoLineGap = json.sTypoLineGap;
      OS2.usWinAscent = json.usWinAscent;
      OS2.usWinDescent = json.usWinDescent;
      OS2.ulCodePageRange1 = json.ulCodePageRange1;
      OS2.ulCodePageRange2 = json.ulCodePageRange2;
      OS2.sxHeight = json.sxHeight;
      OS2.sCapHeight = json.sCapHeight;
      OS2.usDefaultChar = json.usDefaultChar;
      OS2.usBreakChar = json.usBreakChar;
      OS2.usMaxContext = json.usMaxContext;
      return OS2;
    };

    return OS_2Table;

  })();











  TrueType = (function() {

    function TrueType() {
      this.sfntHeader = {
        sfntVersion: 0,
        numTables: 0,
        searchRange: 0,
        entrySelector: 0,
        rangeShift: 0
      };
      this.offsetTable = [];
      this.head = new HeadTable();
      this.maxp = new MaxpTable();
      this.loca = new LocaTable();
      this.glyf = new GlyfTable();
      this.hhea = new HheaTable();
      this.hmtx = new HmtxTable();
      this.OS_2 = new OS_2Table();
    }

    TrueType.prototype.isMacTTF = function() {
      return this.sfntHeader.sfntVersion === 'true';
    };

    TrueType.prototype.isWinTTF = function() {
      return this.sfntHeader.sfntVersion === 1.0;
    };

    TrueType.prototype.isTTCF = function() {
      return this.sfntHeader.sfntVersion === 'ttcf';
    };

    TrueType.prototype.isTTF = function() {
      return this.isMacTTF() || this.isWinTTF() || this.isTTCF();
    };

    TrueType.prototype.isOTTO = function() {
      return this.sfntHeader.sfntVersion === 'OTTO';
    };

    TrueType.prototype.isCFF = function() {
      return this.isOTTO();
    };

    TrueType.prototype.getNumGlyphs = function() {
      return this.maxp.numGlyphs;
    };

    TrueType.prototype.isLocaLong = function() {
      return this.head.isLocaLong();
    };

    TrueType.prototype.getGlyphById = function(id) {
      var glyphData;
      if (this.getNumGlyphs() === 0) {
        return false;
      }
      glyphData = this.glyf.getGlyphById(id);
      if (glyphData === false) {
        return false;
      }
      return new Glyph(glyphData, this);
    };

    TrueType.createFromBuffer = function(buffer) {
      var checkSum, i, length, offset, sfntVersionNumber, sfntVersionString, tableOffsets, tag, ttf, view;
      ttf = new TrueType();
      view = new TTFDataView(buffer);
      sfntVersionString = view.getString(4, 0);
      sfntVersionNumber = view.getFixed(0);
      ttf.sfntHeader.sfntVersion = sfntVersionNumber === 1.0 ? sfntVersionNumber : sfntVersionString;
      if (ttf.isTTF() && !ttf.isTTCF() || ttf.isOTTO()) {
        ttf.sfntHeader.numTables = view.getUshort(4);
        ttf.sfntHeader.searchRange = view.getUshort();
        ttf.sfntHeader.entrySelector = view.getUshort();
        ttf.sfntHeader.rangeShift = view.getUshort();
        if (ttf.sfntHeader.numTables > 0) {
          tableOffsets = {};
          ttf.offsetTable = (function() {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = ttf.sfntHeader.numTables - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              tag = view.getString(4);
              checkSum = view.getUlong().toString(16);
              offset = view.getUlong();
              length = view.getUlong();
              tableOffsets[tag] = offset;
              _results.push({
                tag: tag,
                checkSum: checkSum,
                offset: offset,
                length: length
              });
            }
            return _results;
          })();
          if (typeof tableOffsets.head !== 'undefined') {
            ttf.head = HeadTable.createFromTTFDataView(view, tableOffsets.head, ttf);
          }
          if (typeof tableOffsets.maxp !== 'undefined') {
            ttf.maxp = MaxpTable.createFromTTFDataView(view, tableOffsets.maxp, ttf);
          }
          if (typeof tableOffsets.loca !== 'undefined') {
            ttf.loca = LocaTable.createFromTTFDataView(view, tableOffsets.loca, ttf);
          }
          if (typeof tableOffsets.glyf !== 'undefined') {
            ttf.glyf = GlyfTable.createFromTTFDataView(view, tableOffsets.glyf, ttf);
          }
          if (typeof tableOffsets.hhea !== 'undefined') {
            ttf.hhea = HheaTable.createFromTTFDataView(view, tableOffsets.hhea, ttf);
          }
          if (typeof tableOffsets.hmtx !== 'undefined') {
            ttf.hmtx = HmtxTable.createFromTTFDataView(view, tableOffsets.hmtx, ttf);
          }
          if (typeof tableOffsets['OS/2'] !== 'undefined') {
            ttf.OS_2 = OS_2Table.createFromTTFDataView(view, tableOffsets['OS/2'], ttf);
          }
        }
      }
      return ttf;
    };

    TrueType.createFromJSON = function(json) {
      var ttf;
      if (typeof json === 'string') {
        json = JSON.parse(json);
      }
      ttf = new TrueType();
      ttf.sfntHeader.sfntVersion = json.sfntHeader.sfntVersion;
      if (ttf.isTTF() && !ttf.isTTCF() || ttf.isOTTO()) {
        ttf.sfntHeader.numTables = json.sfntHeader.numTables;
        ttf.sfntHeader.searchRange = json.sfntHeader.searchRange;
        ttf.sfntHeader.entrySelector = json.sfntHeader.entrySelector;
        ttf.sfntHeader.rangeShift = json.sfntHeader.rangeShift;
        if (ttf.sfntHeader.numTables > 0) {
          ttf.offsetTable = json.offsetTable;
          if (typeof json.head !== 'undefined') {
            ttf.head = HeadTable.createFromJSON(json.head);
          }
          if (typeof json.maxp !== 'undefined') {
            ttf.maxp = MaxpTable.createFromJSON(json.maxp);
          }
          if (typeof json.loca !== 'undefined') {
            ttf.loca = LocaTable.createFromJSON(json.loca);
          }
          if (typeof json.glyf !== 'undefined') {
            ttf.glyf = GlyfTable.createFromJSON(json.glyf);
          }
          if (typeof json.hhea !== 'undefined') {
            ttf.hhea = HheaTable.createFromJSON(json.hhea);
          }
          if (typeof json.hmtx !== 'undefined') {
            ttf.hmtx = HmtxTable.createFromJSON(json.hmtx);
          }
          if (typeof json.OS_2 !== 'undefined') {
            ttf.OS_2 = OS_2Table.createFromJSON(json.OS_2);
          }
        }
      }
      return ttf;
    };

    TrueType.prototype.toJSONString = function() {
      var glyph, json, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.glyf.glyphs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        glyph = _ref[_i];
        glyph.glyfTable = '[GlyfTable]';
      }
      json = JSON.stringify.apply(null, [this].concat(arguments));
      _ref1 = this.glyf.glyphs;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        glyph = _ref1[_j];
        glyph.glyfTable = this.glyf;
      }
      return json;
    };

    return TrueType;

  })();


  jDataView = typeof require !== 'undefined' ? require('jdataview') : this.jDataView;

  TTFDataView = (function() {

    function TTFDataView(buffer) {
      this.buffer = buffer;
      this.view = new jDataView(this.buffer);
    }

    TTFDataView.prototype.seek = function(offset) {
      if (typeof offset === 'number') {
        this.view.seek(offset);
      }
      return this;
    };

    TTFDataView.prototype.tell = function() {
      return this.view.tell();
    };

    TTFDataView.prototype.getString = function(length, offset) {
      return this.view.getString(length, offset);
    };

    TTFDataView.prototype.getByte = function(offset) {
      return this.view.getUint8(offset);
    };

    TTFDataView.prototype.getChar = function(offset) {
      return this.view.getInt8(offset);
    };

    TTFDataView.prototype.getUshort = function(offset) {
      return this.view.getUint16(offset);
    };

    TTFDataView.prototype.getShort = function(offset) {
      return this.view.getInt16(offset);
    };

    TTFDataView.prototype.getUlong = function(offset) {
      return this.view.getUint32(offset);
    };

    TTFDataView.prototype.getLong = function(offset) {
      return this.view.getInt32(offset);
    };

    /**
     * Return 32-bit signed fixed-point number (16.16).
     * @param {number} `offset` offset.
    */


    TTFDataView.prototype.getFixed = function(offset) {
      var fraction, mantissa;
      if (typeof offset === 'number') {
        this.seek(offset);
      }
      mantissa = this.view.getInt16();
      fraction = this.view.getUint16() / Math.pow(2, 16);
      return Math.ceil((mantissa + fraction) * 1000) / 1000;
    };

    TTFDataView.prototype.getF2dot14 = function(offset) {
      var fraction, mantissa, value;
      if (typeof offset === 'number') {
        this.seek(offset);
      }
      value = this.view.getUint16();
      mantissa = [0, 1, -2, -1][value >>> 14];
      fraction = (value & 0x3fff) / Math.pow(2, 14);
      return Math.round((mantissa + fraction) * 1000000) / 1000000;
    };

    /**
     * Return the long internal format of a date
     * in seconds since 12:00 midnight, January 1, 1904.
     * It is represented as a signed 64-bit integer.<br />
     *
     * This method has been ported form the FontForge. <br />
     * https://github.com/fontforge/fontforge/blob/v20120731-b/fonttools/showttf.c#L483-L516
     * @param {number} offset offset.
     * @return {Date} date.
    */


    TTFDataView.prototype.getLongDateTime = function(offset) {
      var date, date1970, i, unixtime, year, _i, _j;
      if (typeof offset === 'number') {
        this.seek(offset);
      }
      date = [0, 0, 0, 0];
      date1970 = [0, 0, 0, 0];
      year = [];
      date[3] = this.getUshort();
      date[2] = this.getUshort();
      date[1] = this.getUshort();
      date[0] = this.getUshort();
      year[0] = (60 * 60 * 24 * 365) & 0xffff;
      year[1] = (60 * 60 * 24 * 365) >> 16;
      for (i = _i = 1904; _i <= 1969; i = ++_i) {
        date1970[0] += year[0];
        date1970[1] += year[1];
        if ((i & 3) === 0 && (i % 100 !== 0 || i % 400 === 0)) {
          date1970[0] += 24 * 60 * 60;
        }
        date1970[1] += date1970[0] >> 16;
        date1970[0] &= 0xffff;
        date1970[2] += date1970[1] >> 16;
        date1970[1] &= 0xffff;
        date1970[3] += date1970[2] >> 16;
        date1970[2] &= 0xffff;
      }
      for (i = _j = 0; _j <= 3; i = ++_j) {
        date[i] -= date1970[i];
        date[i + 1] += date[i] >> 16;
        date[i] &= 0xffff;
      }
      date[3] -= date1970[3];
      unixtime = ((date[1] << 16) | date[0]) * 1000;
      return new Date(unixtime);
    };

    TTFDataView.prototype.getUFWord = function(offset) {
      return this.getUshort(offset);
    };

    TTFDataView.prototype.getFWord = function(offset) {
      return this.getShort(offset);
    };

    TTFDataView.prototype.getUshortFlags = function(offset) {
      var flags, i, num, _i, _results;
      flags = this.getUshort(offset);
      _results = [];
      for (i = _i = 0; _i <= 15; i = ++_i) {
        _results.push(num = (flags & Math.pow(2, i)) === 0 ? 0 : 1);
      }
      return _results;
    };

    TTFDataView.prototype.getUlongFlags = function(offset) {
      var flags, i, num, _i, _results;
      flags = this.getUlong(offset);
      _results = [];
      for (i = _i = 0; _i <= 31; i = ++_i) {
        _results.push(num = (flags & Math.pow(2, i)) === 0 ? 0 : 1);
      }
      return _results;
    };

    return TTFDataView;

  })();


  /*
  exports
  */


  ttfjs = {
    TrueType: TrueType,
    TTFDataView: TTFDataView,
    table: {
      HeadTable: HeadTable,
      LocaTable: LocaTable,
      MaxpTable: MaxpTable,
      GlyfTable: GlyfTable,
      HheaTable: HheaTable,
      HmtxTable: HmtxTable,
      OS_2Table: OS_2Table
    },
    glyph: {
      SimpleGlyphData: SimpleGlyphData,
      CompositeGlyphData: CompositeGlyphData
    }
  };

  if (typeof module !== 'undefined') {
    module.exports = ttfjs;
  } else {
    this.ttfjs = ttfjs;
  }

}).call(this);
